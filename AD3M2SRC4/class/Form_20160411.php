<?phpclass Form extends Html {    /**     * EGMC 20150701     * Es la variable que se utiliza para saber si      * la clase ya fue instanciada sirve para patrón singleton     * @var instance de la clase Html     */    protected static $instance;    public $attrsForm = array(        'id' => 'datos',        'name' => 'datos',        'action' => '',        'method' => 'POST',        'class' => '',//        'style' => '',        'role' => 'form',//            'enctype' => 'multipart/form-data',//            'autocomplete' => 'on',//            'target' => ''    );    public $baseFormDivContent = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => array(10, 'offset-1'), 'md' => array(8, 'offset-2')))    );    /**     * EGMC 20150706     * Variable que indica si hay un contenedor general en el formulario     * @var string     */    private $formDivContent = '';    public $attrsInput = array(        'id' => '',        'name' => '',        'class' => 'form-control ',//        'style' => '',//        'placeholder' => ''    );    public $baseDivGroup = array(        'attributes' => array('class' => 'form-group'),        'options' => array()    );    public $baseInputLabel = array(        'content' => '',        'attributes' => array('class' => 'control-label'),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseInputDiv = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    public $attrsCheckbox = array(        'id' => '',        'name' => '',        'class' => '',        'type' => 'checkbox',    );    public $baseCheckboxLabel = array(        'content' => '',        'attributes' => array('for' => ''),        'icon' => '',        'infoPopover' => array(),        'options' => array()    );    public $baseCheckboxDiv = array(        'attributes' => array('class' => 'checkbox-nice'),        'options' => array('grids' => array('xs' => 12, 'sm' => array(10, 'offset-2'), 'md' => array(8, 'offset-4'), 'lg' => array(8, 'offset-4')))    );    public $attrsRadio = array(        'id' => '',        'name' => '',        'class' => '',        'type' => 'radio',    );    public $baseRadioLabel = array(        'content' => '',        'attributes' => array('for' => ''),        'icon' => '',        'infoPopover' => array(),        'options' => array()    );    public $baseRadioDiv = array(        'attributes' => array('class' => 'radio'),        'options' => array('grids' => array('xs' => 12, 'sm' => array(10, 'offset-2'), 'md' => array(8, 'offset-4'), 'lg' => array(8, 'offset-4')))    );    public $attrsTextarea = array(        'id' => '',        'name' => '',        'class' => 'form-control',    );    public $baseTextareaLabel = array(        'content' => '',        'attributes' => array(            'for' => '',            'class' => 'control-label'),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseTextareaDiv = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    public $attrsSelect = array(        'id' => '',        'name' => '',//        'class' => 'form-control',        'class' => 'select2',        'style' => 'width:100%',//        'data-placeholder' => 'Selecciona Nombre'    );    public $baseSelectLabel = array(        'content' => '',        'attributes' => array(            'for' => '',            'class' => 'control-label'),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseSelectDiv = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    public $attrsSubmit = array(        'type' => 'submit',        'class' => 'btn btn-primary btn-lg btnSave'    );    public $attrsCancel = array(        'type' => 'button',        'class' => 'btn btn-danger btn-lg btnCancel',        'onclick' => "return history.go(-1);"    );    public $attrsDelete = array(        'type' => 'button',        'class' => 'btn btn-danger btn-lg btnDelete',            //'onclick' => "return history.go(-1);"    );    public $attrsAutocomplete = array(        'id' => '',        'name' => '',        'class' => 'form-control autocompleteTypeahead',        'data-remote-url' => ''//        'style' => '',//        'placeholder' => ''    );    public $baseAutocompleteLabel = array(        'content' => '',        'attributes' => array(            'for' => '',            'class' => 'control-label'),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseAutocompleteDiv = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    public $attrsTimepicker = array(        'id' => '',        'name' => '',        'class' => 'form-control bootstrapTimepicker'//       ,'style' => '',    );    public $baseTimepickerLabel = array(        'content' => '',        'attributes' => array(            'class' => 'control-label',            'for' => ''),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseTimepickerDiv = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    public $attrsDatepicker = array(        'id' => '',        'name' => '',        'class' => 'form-control bootstrapDatepicker'//       ,'style' => '',    );    public $baseDatepickerLabel = array(        'content' => '',        'attributes' => array(            'class' => 'control-label',            'for' => ''),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseDatepickerDiv = array(        'attributes' => array('class' => ''),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    public $baseInformationLabel = array(        'content' => '',        'attributes' => array('class' => 'control-label'),        'icon' => '',        'infoPopover' => array(),        'options' => array('grids' => array('xs' => 12, 'sm' => 2, 'md' => 4, 'lg' => 4))    );    public $baseInformationDiv = array(        'attributes' => array(            'class' => 'control-label',            'style' => 'text-align:left;'        ),        'options' => array('grids' => array('xs' => 12, 'sm' => 10, 'md' => 8, 'lg' => 8))    );    /**     * EGMC 20150701     * contructor privado para aplicar patrón singleton     */    private function __construct() {//        Dbg::data('Se creó class Form');    }    /**     * EGMC 20150701     * Aplica patrón singleton con herencia     * @return class regresa la instancia del objeto     */    public static function getInstance() {        /**         * Comprueba si existe una clase ancestra         */        if (get_parent_class() && get_parent_class() != get_class()) {            /**             *  Llama al constructor de la clase padre             */            parent::getInstance();            /**             *  Se extraé en un array las propiedades de la clase base             */            $varsParent = get_object_vars(parent::$instance);            /**             * Se crea la instancia de la clase actual si es necesario             */            if (!(self::$instance instanceof self)) {                self::$instance = new self();            }            /**             * Se vinculan (por referencia gracias al caracter &) las              * propiedades de clase actual a las de su ancestro             */            while (is_array($varsParent) && $tupla = each($varsParent)) {                self::$instance->$tupla[0] = &parent::$instance->$tupla[0];            }        } elseif (!self::$instance instanceof self) {            self::$instance = new self;        }        return self::$instance;    }    /**     * EGMC 20150706     * Aplica un vacio a todos los elementos (grids)     */    public function removeFormatInlineLabels() {        $this->baseInputLabel['options']['grids'] = array();        $this->baseInputDiv['options']['grids'] = array();        $this->baseTextareaLabel['options']['grids'] = array();        $this->baseTextareaDiv['options']['grids'] = array();        $this->baseSelectLabel['options']['grids'] = array();        $this->baseSelectDiv['options']['grids'] = array();        $this->baseCheckboxDiv['options']['grids'] = array();        $this->baseTimepickerLabel['options']['grids'] = array();        $this->baseTimepickerDiv['options']['grids'] = array();        $this->baseDatepickerLabel['options']['grids'] = array();        $this->baseDatepickerDiv['options']['grids'] = array();        /*          $this->baseRadioLabel ['options']['grids'] = array();          $this->baseRadioDiv ['options']['grids'] = array();         */        $this->baseAutocompleteLabel['options']['grids'] = array();        $this->baseAutocompleteDiv['options']['grids'] = array();        $this->baseInformationLabel['options']['grids'] = array();        $this->baseInformationDiv['options']['grids'] = array();    }    /**     * EGMC 20150630     * Regresa tag abierto de form y un div contenedor      * @param array $attributes que contiene el tag form     * @param bool $inlineLabels indica la forma en la que se aliniarán los datos     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @return string     */    public function open($attributes = array(), $divContent = array(), $inlineLabels = true, $options = array()) {        $attributes += $this->attrsForm;        $options += $this->extraOptions;//        $attributes['class'].=($horizontal) ? " form-horizontal " : " form-inline ";        if (!$inlineLabels) {            $this->removeFormatInlineLabels();        } else {            $attributes['class'].=" form-horizontal ";        }        /**         * EGMC 20150706         * Agregamos caracteristicas del div contenedor         */        if ($divContent !== false) {            $divContent += $this->baseFormDivContent;            if (!empty($divContent['options']['grids'])) {                $divContent['attributes']['class'].= ' ' . $this->formatGrids($divContent['options']['grids']) . ' ';            }            $this->formDivContent = '<div ' . General::arrayToAttrs($divContent['attributes']) . '>';        }        return $options['before'] . '<form ' . General::arrayToAttrs($attributes) . ' >' . $this->formDivContent . $options['after'];    }    /**     * EGMC 20150630     * Regresa tag cerrado de form con botones submit y cancelar     *      * @param array|false $buttonSave     *        array     *            'label' => 'Guardar Cambios',     *            'icon' => nombre del icon que contendrá el botón      'attributes' => $this->attrsSubmit,      'options' => array()     * @param array|false $buttonCancel     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @return string     * <!-- HTML $options['before'] -->     * <hr>     * <ul class="text-center list-inline">     *    <li>     *        <button type="submit" class="btn btn-primary btn-lg">     *            <!-- Icon que se inserta en la etiqueta -->     *            <span class="fa fa-save">&nbsp;</span>     *                Guardar Cambios     *        </button>     *    </li>     *    <li>     *        <button type="button" class="btn btn-danger btn-lg" onclick="return history.go(-1);">     *            <!-- Icon que se inserta en la etiqueta -->     *            <span class="fa fa-times">&nbsp;</span>     *                Cancelar     *        </button>     *    </li>     * </ul>     *      * </div>     * </form>     * <!-- HTML $options['after'] -->     */    public function close($buttonSave = array(), $buttonCancel = array(), $options = array(), $buttonDelete = false) {        $options += $this->extraOptions;        /**         * EGMC 20150706         * Se agregan los botones         */        $contentButtons = '';        if ($buttonCancel !== false || $buttonSave !== false || $buttonDelete !== false) {            $contentButtons = '<hr><ul class="text-center list-inline">';            if ($buttonSave !== false) {                $buttonSave += array(                    'label' => 'Guardar Cambios',                    'icon' => 'save',                    'attributes' => $this->attrsSubmit,                    'options' => array()                );                $contentButtons .= '<li>' . $this->bttnSubmit($buttonSave['label'], $buttonSave['icon'], $buttonSave['attributes'], $buttonSave['options']) . '</li>';            }            if ($buttonCancel !== false) {                $buttonCancel += array(                    'label' => 'Cancelar',                    'icon' => 'times',                    'redirect' => '',                    'attributes' => $this->attrsCancel,                    'options' => array()                );                $contentButtons .= '<li>' . $this->bttnCancel($buttonCancel['label'], $buttonCancel['redirect'], $buttonCancel['icon'], $buttonCancel['attributes'], $buttonCancel['options']) . '</li>';            }            if ($buttonDelete !== false) {                $buttonDelete += array(                    'label' => 'Eliminar',                    'icon' => 'trash-o',                    'messageConfirm' => '',                    'redirectTo' => '',                    'attributes' => $this->attrsDelete,                    'options' => array()                );                $contentButtons .= '<li>' . $this->bttnDelete($buttonDelete['label'], $buttonDelete['messageConfirm'], $buttonDelete['redirectTo'], $buttonDelete['icon'], $buttonDelete['attributes'], $buttonDelete['options']) . '</li>';            }            $contentButtons.='</ul>';        }        /**         * EGMC 20150706         * Se agrega el tag de cierre del formulario         */        $closeForm = '</form>';        /**         * EGMC 20150706         * Comprueba si existe un contenedor sì existe lo cierra         */        $closeForm = ($this->formDivContent != '' ? '</div>' : '') . $closeForm;        return $options['before'] . $contentButtons . $closeForm . $options['after'];    }    /**     * EGMC 20150701     * Regresa un tag input con formato boostrap     * @param string $name nombre del input     * @param string $value valor del input     * @param string|array|false $label etiqueta del input     *        string => cadena de texto de la etiqueta     *        array     *           'content' => string cadena de texto de la etiqueta,     *           'attributes' => array arreglo de atributos que puede tener la etiqueta     *           'icon' => string nombre de icono que contendrá la etiqueta     *           'infoPopover' => string|array cadena con el texto informativo      *                            o arreglo con atributos para generar el popover     *           'options' => array arreglo con datos extra     *                            'before' => html que se inserta antes     *                            'after' => html que se inserta después      *        false => si no queremos mostrar ninguna etiquéta     * @param string $error mensaje de error del input     * @param array $attributes atributos del input     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @param array|false $inputDiv elementos extra que tendrá el contenedor del input     * @param array|false $divGroup elementos extra que tendrá el contenedor de todo el elemento     * @return string input con formato boostrap     * <!-- HTML de $options['before'] ->     * <!-- Se agregar la clase has-error en caso de que exista error -->     * <div class="form-group has-error">     *     <label class="control-label">     *         <!-- Icono -->     *         <i class="fa fa-icon"></i>&nbsp;     *             Etiqueta     *         <!-- Información popover -->     *         <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *     </label>     *     <div>         *         <input class="form-control" id="IdInput" name="id_input" placeholder="Placeholder" type="text" value="valor input">     *         <!--En caso de que exista error-->     *         <span class="help-block"><i class="fa fa-warning"></i> Mensaje de error</span>     *     </div>     * </div>     * <!-- HTML de $options['after'] ->     */    public function input($name, $value = '', $label = array(), $error = array(), $attributes = array(), $options = array(), $inputDiv = array(), $divGroup = array()) {        $htmlLabel = '';        $htmlError = '';        //INICIA CONSTRUCCIÓN DE HTML INPUT        $attributes += $this->attrsInput;        $options += $this->extraOptions;        $attributes['name'] = $name;        $attributes['value'] = $value;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        //INICIA CONSTRUCCIÓN DE HTML ERROR        if ($error !== false && !empty($error)) {            /**             * Con clases             */            //$htmlError = $this->tag('span', array('class' => 'help-block'),  $this->tag('i', array('class' => 'fa fa-warning')) .$error);            /**             * Sin Clase es más eficiente             */            $htmlError = '<span class="help-block"><i class="fa fa-warning"></i>&nbsp;' . $error . '</span>' . "\r\n";        }        //FIN CONSTRUCCIÓN DE HTML ERROR        $htmlInput = $this->tag('input', $attributes, '') . $htmlError;        /**         * Se agregan las opciones base del div que contiene al input         */        if ($inputDiv !== false) {            $inputDiv += $this->baseInputDiv;            $htmlInput = $this->div($htmlInput, $inputDiv['attributes'], $inputDiv['options']);        }        //FIN CONSTRUCCIÓN DE HTML INPUT        //INICIA CONSTRUCCIÓN DE HTML LABEL        if ($label !== false) {            /**             * Si la etiqueta está vacía asignamos el nombre del elemento             */            if (empty($label)) {                $label['content'] = $name;            }            /**             * Si label es una cadena entonces asignamos el contenido             */            if (is_string($label)) {                $label = (array) $label;                $label['content'] = $label[0];                unset($label[0]);            }            $label += $this->baseInputLabel;            $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        }        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCCIÓN DE DIV        if ($divGroup !== false) {            $divGroup += $this->baseDivGroup;            if ($htmlError != '') {                $divGroup['attributes']['class'].=' has-error ';            }//            Dbg::data($divGroup);            return $options['before'] . $this->div($htmlLabel . $htmlInput, $divGroup['attributes'], $divGroup['options']) . $options['after'];        }        //FIN CONSTRUCCIÓN DE DIV        return $options['before'] . $htmlLabel . $htmlInput . $options['after'];    }    /**     * EGMC 20150708     * Regresa un tag input de tipo oculto (hidden)     *      * @param string $name     * @param string $value     * @param array $attributes     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @return string tag input de tipo oculto     * <!-- HTML de $options['before'] ->     * <input type="hidden" id="InputHidden" name="input_hidden" value="value" />     * <!-- HTML de $options['after'] ->     */    public function hidden($name, $value = '', $attributes = array(), $options = array()) {        $attributes['type'] = 'hidden';        $attributes += array('class' => '');        return $this->input($name, $value, false, false, $attributes, $options, false, false);    }    public function textarea($name, $content = '', $label = array(), $error = '', $attributes = array(), $options = array(), $textareaDiv = array(), $divGroup = array()) {        $htmlLabel = '';        $htmlError = '';        //INICIA CONSTRUCCIÓN DE HTML TEXTAREA        $attributes += $this->attrsTextarea;        $options += $this->extraOptions;        $attributes['name'] = $name;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        //INICIA CONSTRUCCIÓN DE HTML ERROR        if ($error !== false && !empty($error)) {            /**             * Con clases             */            //$htmlError = $this->tag('span', array('class' => 'help-block'),  $this->tag('i', array('class' => 'fa fa-warning')) .$error);            /**             * Sin Clase es más eficiente             */            $htmlError = '<span class="help-block"><i class="fa fa-warning"></i>&nbsp;' . $error . '</span>';        }        //FIN CONSTRUCCIÓN DE HTML ERROR        $htmlTextarea = $this->tag('textarea', $attributes, $content) . $htmlError;        /**         * Se agregan las opciones base del div que contiene al input         */        if ($textareaDiv !== false) {            $textareaDiv += $this->baseTextareaDiv;            $htmlTextarea = $this->div($htmlTextarea, $textareaDiv['attributes'], $textareaDiv['options']);        }        //FIN CONSTRUCCIÓN DE HTML TEXTAREA        //INCIA CONSTRUCCIÓN DE HTML LABEL        if ($label !== false) {            /**             * Si la etiqueta está vacía asignamos el nombre del elemento             */            if (empty($label)) {                $label['content'] = $name;            }            /**             * Si label es una cadena entonces asignamos el contenido             */            if (is_string($label)) {                $label = (array) $label;                $label['content'] = $label[0];                unset($label[0]);            }            $label += $this->baseTextareaLabel;            $label['attributes']['for'] = $attributes['id'];            $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        }        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCCIÓN DE DIV        if ($divGroup !== false) {            $divGroup += $this->baseDivGroup;            if ($htmlError != '') {                $divGroup['attributes']['class'].=' has-error ';            }            return $options['before'] . $this->div($htmlLabel . $htmlTextarea, $divGroup['attributes'], $divGroup['options']) . $options['after'];        }        //FIN CONSTRUCCIÓN DE DIV        return $options['before'] . $htmlLabel . $htmlTextarea . $options['after'];    }    public function wysiwygCKeditor($name, $content = '', $label = array(), $error = '', $attributes = array(), $options = array(), $textareaDiv = array(), $divGroup = array()) {        $attributes += $this->attrsTextarea;        $attributes['class'] .= ' wysiwygCKeditor ';        if (is_string($label)) {            $label = (array) $label;            $label['content'] = $label[0];            unset($label[0]);        }        if (!isset($label['options']['grids'])) {            $label['options']['grids'] = array();        }        if (!isset($textareaDiv['options']['grids'])) {            $textareaDiv['options']['grids'] = array();        }//        Dbg::data($label);        return $this->textarea($name, $content, $label, $error, $attributes, $options, $textareaDiv, $divGroup);    }    /**     * EGMC 20150710     * Regresa un tag textarea con formato boostrap y con la funcionalidad     * de wysiwyg Summernote (http://summernote.org)     *      * @param string $name     * @param string $content     * @param type|array|false $label     * @param string $error     * @param array $attributes     * @param array $options     * @param array $textareaDiv     * @param array $divGroup     * @return string tags para formar wysiwygSummernote      * <!-- HTML de $options['before'] ->     * <!-- Se agregar la clase has-error en caso de que exista error -->     * <div class="form-group has-error ">     *    <label for="Summernote" class="control-label">     *         <!-- Icono -->     *         <i class="fa fa-icon"></i>&nbsp;     *             Etiqueta     *         <!-- Información popover -->     *         <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *     </label>     *    <div class="wysiwygSummernote" data-textarea-id="Summernote">     *        Contenido de textarea     *    </div>     *    <div>     *        <textarea data-airmode="false" data-height="100" id="Summernote" name="summernote" class="form-control" style=" display:none; ">     *           Contenido de textarea     *        </textarea>     *           <!--En caso de que exista error-->     *        <span class="help-block"><i class="fa fa-warning"></i>&nbsp; Mensaje de error</span>     *     </div>     * </div>     * <!-- HTML de $options['after'] ->     */    public function wysiwygSummernote($name, $content = '', $label = array(), $error = '', $attributes = array(), $options = array(), $textareaDiv = array(), $divGroup = array()) {        $attributes += $this->attrsTextarea;        $attributes['name'] = $name;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        /**         * Se fuerza a que el textarea no se vea         */        if (!isset($attributes['style']) || $attributes['style'] == '') {            $attributes['style'] = ' display:none; ';        } else {            $attributes['style'] .= ' display:none; ';        }        if (is_string($label)) {            $label = (array) $label;            $label['content'] = $label[0];            unset($label[0]);        }        if (!isset($label['options']['grids'])) {            $label['options']['grids'] = array();        }        if (!isset($textareaDiv['options']['grids'])) {            $textareaDiv['options']['grids'] = array();        }        /**         * Se crea el div al cual se le va a          */        $divWYSIWYG = $this->tag('div', array(            'class' => 'wysiwygSummernote',            'data-textarea-id' => $attributes['id']), $content);        $textareaDiv+=$this->baseTextareaDiv;        $textareaDiv['options']['before'] = $divWYSIWYG;        return $this->textarea($name, $content, $label, $error, $attributes, $options, $textareaDiv, $divGroup);    }    /**     * EGMC 20150715     *      *      * @param type $name     * @param type $display     * @param type $remoteURL     * @param type $label     * @param type $error     * @param type $attributes     * @param type $options     * @param type $inputDiv     * @param type $divGroup     * @return string     *      * <!-- HTML de $options['before'] ->     * <!-- Se agregar la clase has-error en caso de que exista error -->     * <div class="form-group has-error ">     *     <label for="FuaAutocompleteName" class="control-label">     *         <!-- Icono -->     *         <i class="fa fa-user-md"></i>&nbsp;     *         Etiqueta     *         <!-- Información popover -->     *         <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *     </label>     *     <div>     *         <input type="hidden" name="autocomplete_name" id="AutocompleteName" >     *         <input type="text"      *                id="FuaAutocompleteName"      *                name="Fua[autocomplete_name]"      *                class="form-control"      *                data-input-id="AutocompleteName"      *                data-input-display-value="id"      *                data-remote-url="data-test/repos.json?query=%QUERY"      *                data-templates-empty="<div>No hay resultados</div>"      *                data-templates-suggestion="<div><p class='tt-suggestion-title-right'>{{language}}</p><p class='tt-suggestion-name'>{{name}}</p><p class='tt-suggestion-description'>{{description}}</p></div>" >     *         <!--En caso de que exista error-->     *         <span class="help-block"><i class="fa fa-warning"></i>&nbsp; Mensaje de error</span>     *     </div>     * </div>     * <!-- HTML de $options['after'] ->     */    public function autocomplete($name, $hiddeValue = '', $display = '', $remoteURL = '', $label = array(), $error = '', $attributes = array(), $options = array(), $inputDiv = array(), $divGroup = array()) {        if ($display == '') {            $display = $hiddeValue;        }        if (isset($attributes['id'])) {            if ($attributes['id'] == '') {                $idHidden = String::upperCamelize($name);            } else {                $idHidden = $attributes['id'];            }        } else {            $idHidden = String::upperCamelize($name);        }        $hiddenHTML = $this->hidden($name, $hiddeValue, array('id' => $idHidden));        //Dbg::data($hiddenHTML);        $attributes += $this->attrsAutocomplete;        $name = 'Fua[' . String::upperCamelize($name) . ']';        $attributes['id'] = String::upperCamelize($name);        $attributes['data-input-id'] = $idHidden;        $attributes['data-remote-url'] = $remoteURL;        if (is_string($label)) {            $label = (array) $label;            $label['content'] = $label[0];            unset($label[0]);        }        //Dbg::data($label);        $inputDiv+=$this->baseAutocompleteDiv;        $inputDiv['options']['before'] = $hiddenHTML;        return $this->input($name, $display, $label, $error, $attributes, $options, $inputDiv, $divGroup);    }    public function select($name, $selectOptions = array(), $selected = '', $label = array(), $error = '', $attributes = array(), $options = array(), $selectDiv = array(), $divGroup = array()) {        $selected = (array) $selected;        $htmlLabel = '';        $htmlError = '';        $content = array();        //INICIA CONSTRUCCIÓN DE HTML SELECT        $attributes += $this->attrsSelect;        $options += $this->extraOptions;        $attributes['name'] = $name;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        //INICIA CONSTRUCCIÓN DE CONTENIDO (OPTIONS) PARA EL TAG HTML SELECT        if (!empty($selectOptions)) {            foreach ($selectOptions as $optionValue => $optionContent) {                if (is_array($optionContent)) {                    $optgroup = array();                    foreach ($optionContent as $optgroupValue => $optgroupContent) {                        $optgroup[] = '<option value="' . $optgroupValue . '" ' . (in_array($optgroupValue, $selected) ? 'selected="selected"' : '') . ' >' . $optgroupContent . '</option>';                    }                    $content[] = '<optgroup label="' . $optionValue . '">' . (implode('', $optgroup)) . '</optgroup>';                } else {                    $content[] = '<option value="' . $optionValue . '" ' . (in_array($optionValue, $selected) ? 'selected="selected"' : '') . ' >' . $optionContent . '</option>';                }            }        }        $content = implode('', $content);        //FIN CONSTRUCCIÓN DE CONTENIDO (OPTIONS) PARA EL TAG HTML SELECT        //INICIA CONSTRUCCIÓN DE HTML ERROR        if ($error !== false && !empty($error)) {            /**             * Con clases             */            //$htmlError = $this->tag('span', array('class' => 'help-block'),  $this->tag('i', array('class' => 'fa fa-warning')) .$error);            /**             * Sin Clase es más eficiente             */            $htmlError = '<span class="help-block"><i class="fa fa-warning"></i>&nbsp;' . $error . '</span>';        }        //FIN CONSTRUCCIÓN DE HTML ERROR        $htmlSelect = $this->tag('select', $attributes, $content) . $htmlError;        /**         * Se agregan las opciones base del div que contiene al input         */        if ($selectDiv !== false) {            $selectDiv += $this->baseSelectDiv;            $htmlSelect = $this->div($htmlSelect, $selectDiv['attributes'], $selectDiv['options']);        }        //FIN CONSTRUCCIÓN DE HTML SELECT        //INCIA CONSTRUCCIÓN DE HTML LABEL        if ($label !== false) {            /**             * Si la etiqueta está vacía asignamos el nombre del elemento             */            if (empty($label)) {                $label['content'] = $name;            }            /**             * Si label es una cadena entonces asignamos el contenido             */            if (is_string($label)) {                $label = (array) $label;                $label['content'] = $label[0];                unset($label[0]);            }            $label += $this->baseSelectLabel;            $label['attributes']['for'] = $attributes['id'];            $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        }        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCCIÓN DE DIV        if ($divGroup !== false) {            $divGroup += $this->baseDivGroup;            if ($htmlError != '') {                $divGroup['attributes']['class'].=' has-error ';            }            return $options['before'] . $this->div($htmlLabel . $htmlSelect, $divGroup['attributes'], $divGroup['options']) . $options['after'];        }        //FIN CONSTRUCCIÓN DE DIV        return $options['before'] . $htmlLabel . $htmlSelect . $options['after'];    }    /**     * EGMC 20150706     * Regresa un checkbox con formato de bootstrap     *      * @param string $name     * @param string $value     * @param boolean $checked     * @param string|array|false $label     * @param boolean $inLine     * @param array $attributes     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @param array $checkboxDiv     * @return string tag checkbox      * <!-- HTML de $options['before'] ->     * <!-- se agrega a la clase checkbox-inline si queremos que no exista salto de línea -->     * <div class="checkbox-nice checkbox-inline">     *    <input id="IdCheckbox" type="checkbox">     *    <label for="IdCheckbox">     *        <!-- Icono -->     *        <i class="fa fa-icon"></i>&nbsp;     *            Etiqueta     *        <!-- Información popover -->     *        <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *    </label>     * </div>     * <!-- HTML de $options['after'] ->     */    public function checkbox($name, $value, $checked = false, $label = array(), $inLine = false, $attributes = array(), $options = array(), $checkboxDiv = array()) {        //INICIA CONSTRUCCIÓN DE HTML CHECKBOX        $attributes += $this->attrsCheckbox;        $options += $this->extraOptions;        $attributes['name'] = $name;        $attributes['value'] = $value;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        if ($checked) {            $attributes[] = 'checked';        }        $htmlInput = $this->tag('input', $attributes, '', $options);        //FIN CONSTRUCCIÓN DE HTML CHECKBOX        //INICIA CONSTRUCCIÓN DE HTML LABEL        /**         * Si la etiqueta está vacía asignamos el nombre del elemento         *///        if (empty($label)) {//            $label['content'] = $name;//        }        /**         * Si label es una cadena entonces asignamos el contenido         */        if (is_string($label)) {            $label = (array) $label;            $label['content'] = $label[0];            unset($label[0]);        }        $label += $this->baseCheckboxLabel;        $label['attributes']['for'] = $attributes['id'];        $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCIÓN DE HMTL DIV         if (isset($checkboxDiv['attributes']['class']) && $checkboxDiv['attributes']['class'] != '') {            $checkboxDiv['attributes']['class'].= ' checkbox-nice';        }        $checkboxDiv += $this->baseCheckboxDiv;        if ($inLine) {            $checkboxDiv['attributes']['class'].= ' checkbox-inline';        }        return $this->div($htmlInput . $htmlLabel, $checkboxDiv['attributes'], $checkboxDiv['options']);    }    /**     * EGMC 20150706     * Regresa un radio con formato de bootstrap     *      * @param string $name     * @param string $value     * @param boolean $checked     * @param string|array|false $label     * @param boolean $inLine     * @param array $attributes     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @param array $radioDiv     * @return string tag checkbox      * <!-- HTML de $options['before'] ->     * <!-- se agrega a la clase checkbox-inline si queremos que no exista salto de línea -->     * <div class="radio">     *    <input id="IdCheckbox" type="radio">     *    <label for="IdCheckbox">     *        <!-- Icono -->     *        <i class="fa fa-icon"></i>&nbsp;     *            Etiqueta     *        <!-- Información popover -->     *        <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *    </label>     * </div>     * <!-- HTML de $options['after'] ->     */    public function radio($name, $value, $checked = false, $label = array(), $inLine = false, $attributes = array(), $options = array(), $radioDiv = array()) {        //INICIA CONSTRUCCIÓN DE HTML RADIO        $attributes += $this->attrsRadio;        $options += $this->extraOptions;        $attributes['name'] = $name;        $attributes['value'] = $value;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name . $value);        }        if ($checked) {            $attributes[] = 'checked';        }        $htmlInput = $this->tag('input', $attributes, '', $options);        //FIN CONSTRUCCIÓN DE HTML RADIO        //INICIA CONSTRUCCIÓN DE HTML LABEL        /**         * Si la etiqueta está vacía asignamos el nombre del elemento         */        if (empty($label)) {            $label['content'] = $name;        }        /**         * Si label es una cadena entonces asignamos el contenido         */        if (is_string($label)) {            $label = (array) $label;            $label['content'] = $label[0];            unset($label[0]);        }        $label += $this->baseRadioLabel;        $label['attributes']['for'] = $attributes['id'];        $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCIÓN DE HMTL DIV         if (isset($radioDiv['attributes']['class']) && $radioDiv['attributes']['class'] != '') {            $radioDiv['attributes']['class'].= ' checkbox-nice';        }        $radioDiv += $this->baseRadioDiv;        if ($inLine) {            $radioDiv['attributes']['class'].= ' checkbox-inline';        }        return $this->div($htmlInput . $htmlLabel, $radioDiv['attributes'], $radioDiv['options']);    }    /**     * EGMC 20150706     * Regresa un botón html de tipo submit     *      * @param string $label etiqueta que tendrá el botón     * @param string $redirectTo url a la que redireccionará al pulsar el botón     * @param strin $icon nombre del icono que tendrá el botón     * @param array $attributes atributos del botón     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @return string     * <!-- HTML de $options['before'] ->     * <button class="btn btn-primay" type="submit" >     *     <!-- Icono -->     *     <span class="fa fa-save"></span>     *     Guardar Button     * </button>     * <!-- HTML de $options['after'] ->     */    public function bttnSubmit($label = 'Guardar', $icon = 'save', $attributes = array(), $options = array()) {        $attributes+=$this->attrsSubmit;        return $this->button($label, $icon, $attributes, $options);    }    /**     * EGMC 20150706     * Regresa un botón html que cancela un operación redireccionando      *      * @param string $label etiqueta que tendrá el botón de cancelar     * @param string $redirectTo url a la que redireccionará al pulsar el botón     * @param strin $icon nombre del icono que tendrá el botón     * @param array $attributes atributos del botón     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @return string     * <!-- HTML de $options['before'] ->     * <button class="btn btn-danger" onclick="window.parent.location='listado'">     *     <!-- Icono -->     *     <span class="fa fa-times"></span>     *     Cancel Button     * </button>     * <!-- HTML de $options['after'] ->     */    public function bttnCancel($label = 'Cancelar', $redirectTo = '', $icon = 'times', $attributes = array(), $options = array()) {        $attributes+=$this->attrsCancel;        /**         * Si hay una url para redireccionar agrega la redirección         */        if ($redirectTo != '') {            $attributes['onclick'] = 'window.parent.location="' . $redirectTo . '"';        }        return $this->button($label, $icon, $attributes, $options);    }    /**     * EGMC 20151117     * Regresa un botón html que elimina un registro     *      * @param string $label etiqueta que tendrá el botón     * @param string $messageConfirm mensaje que contendrá el diálogo de confirmación de eliminación     * @param string $redirectTo url a la que redireccionará al pulsar el botón     * @param strin $icon nombre del icono que tendrá el botón     * @param array $attributes atributos del botón     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @return string     * <!-- HTML de $options['before'] ->     * <button class="btn btn-danger" onclick="window.parent.location='listado'">     *     <!-- Icono -->     *     <span class="fa fa-trash"></span>     *     Cancel Button     * </button>     * <!-- HTML de $options['after'] ->     */    public function bttnDelete($label = '', $messageConfirm = '', $redirectTo = '', $icon = 'trash-o', $attributes = array(), $options = array()) {        $attributes+=$this->attrsDelete;        /**         * Si hay una url para redireccionar agrega la redirección         */        if ($messageConfirm != '') {            $attributes['onclick'] = 'if(confirm("' . $messageConfirm . '")){ window.parent.location="' . $redirectTo . '" }';        }        return $this->button($label, $icon, $attributes, $options);    }    /**     * EGMC 20150722     * Regresa input con formato boostrap y con la funcionalidad      * de bootstrap-timepicker (http://jdewit.github.io/bootstrap-timepicker/)     *      * @param string $name nombre del input     * @param string $value valor del input     * @param string|array|false $label etiqueta del timepicker     *        string => cadena de texto de la etiqueta     *        array     *           'content' => string cadena de texto de la etiqueta,     *           'attributes' => array arreglo de atributos que puede tener la etiqueta     *           'icon' => string nombre de icono que contendrá la etiqueta     *           'infoPopover' => string|array cadena con el texto informativo      *                            o arreglo con atributos para generar el popover     *           'options' => array arreglo con datos extra     *                            'before' => html que se inserta antes     *                            'after' => html que se inserta después      *        false => si no queremos mostrar ninguna etiquéta     * @param string $error mensaje de error     * @param array $attributes atributos del timepicker     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @param array|false $timepickerDiv elementos extra que tendrá el contenedor del timepicker     * @param array|false $divGroup elementos extra que tendrá el contenedor de todo el elemento     * @return string input con formato boostrap y función bootstrap-timepicker     *      * <!-- HTML de $options['before'] ->     * <!-- Se agregar la clase has-error en caso de que exista error -->     * <div class="form-group has-error">     *     <label class="control-label" for="">     *         <!-- Icono -->     *         <i class="fa fa-icon"></i>&nbsp;     *             Etiqueta     *         <!-- Información popover -->     *         <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *     </label>     *     <div>     *         <input type="hidden" name="timepicker_name" id="TimepickerName" >     *         <div class="input-group input-append bootstrap-timepicker">         *             <input class="form-control bootstrapTimepicker" id="FuaTimepickerName" name="Fua[timepicker_name]" type="text" value="valor timepicker">     *             <span class="add-on input-group-addon"><i class="fa fa-clock-o"></i></span>     *          </div>     *          <!--En caso de que exista error-->     *          <span class="help-block"><i class="fa fa-warning"></i> Mensaje de error</span>     *     </div>     * </div>     * <!-- HTML de $options['after'] ->     */    public function timepicker($name, $value = '', $label = array(), $error = array(), $attributes = array(), $options = array(), $timepickerDiv = array(), $divGroup = array()) {        $htmlLabel = '';        $hiddenHTML = '';        $htmlError = '';        if (isset($attributes['id'])) {            if ($attributes['id'] == '') {                $idHidden = String::upperCamelize($name);            } else {                $idHidden = $attributes['id'];            }        } else {            $idHidden = String::upperCamelize($name);        }        $hiddenHTML = $this->hidden($name, $value, array('id' => $idHidden));        $name = 'Fua[' . String::upperCamelize($name) . ']';        $attributes['id'] = String::upperCamelize($name);        $attributes['data-input-id'] = $idHidden;        if (isset($attributes['class'])) {            $attributes['class'] .= ' ' . $this->attrsTimepicker['class'];        }        //INICIA CONSTRUCCIÓN DE HTML INPUT        $attributes += $this->attrsTimepicker;        $options += $this->extraOptions;        $attributes['name'] = $name;//        $attributes['value'] = $value;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        $htmlInput = $this->tag('input', $attributes);        /**         * agregamos el icono de reloj         */        $htmlInput .= '<span class="add-on input-group-addon"><i class="fa fa-clock-o"></i></span>';        //INICIA CONSTRUCCIÓN DE HTML ERROR        if ($error !== false && !empty($error)) {            /**             * Con clases             */            //$htmlError = $this->tag('span', array('class' => 'help-block'),  $this->tag('i', array('class' => 'fa fa-warning')) .$error);            /**             * Sin Clase es más eficiente             */            $htmlError = '<span class="help-block"><i class="fa fa-warning"></i>&nbsp;' . $error . '</span>' . "\r\n";        }        //FIN CONSTRUCCIÓN DE HTML ERROR        $htmlInput = $this->tag('div', array('class' => 'input-group input-append bootstrap-timepicker'), $htmlInput, array('before' => $hiddenHTML,            'after' => $htmlError));        // $htmlInput = $hiddenHTML . $htmlInput . $htmlError;        /**         * Se agregan las opciones base del div que contiene al input         */        if ($timepickerDiv !== false) {            $timepickerDiv += $this->baseTimepickerDiv;            $htmlInput = $this->div($htmlInput, $timepickerDiv['attributes'], $timepickerDiv['options']);        }        //FIN CONSTRUCCIÓN DE HTML INPUT        //        //INICIA CONSTRUCCIÓN DE HTML LABEL        if ($label !== false) {            /**             * Si la etiqueta está vacía asignamos el nombre del elemento             */            if (empty($label)) {                $label['content'] = $name;            }            /**             * Si label es una cadena entonces asignamos el contenido             */            if (is_string($label)) {                $label = (array) $label;                $label['content'] = $label[0];                unset($label[0]);            }            $label += $this->baseTimepickerLabel;            $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        }        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCCIÓN DE DIV        if ($divGroup !== false) {            $divGroup += $this->baseDivGroup;            if ($htmlError != '') {                $divGroup['attributes']['class'].=' has-error ';            }            return $options['before'] . $this->div($htmlLabel . $htmlInput, $divGroup['attributes'], $divGroup['options']) . $options['after'];        }        //FIN CONSTRUCCIÓN DE DIV        return $options['before'] . $htmlLabel . $htmlInput . $options['after'];    }    /**     * EGMC 20150724     * Regresa input con formato boostrap y con la funcionalidad      * de bootstrap-datepiciker (http://bootstrap-datepicker.readthedocs.org/en/stable/)     *      * @param string $name nombre del input     * @param string $value valor del input     * @param string|array|false $label etiqueta del datepicker     *        string => cadena de texto de la etiqueta     *        array     *           'content' => string cadena de texto de la etiqueta,     *           'attributes' => array arreglo de atributos que puede tener la etiqueta     *           'icon' => string nombre de icono que contendrá la etiqueta     *           'infoPopover' => string|array cadena con el texto informativo      *                            o arreglo con atributos para generar el popover     *           'options' => array arreglo con datos extra     *                            'before' => html que se inserta antes     *                            'after' => html que se inserta después      *        false => si no queremos mostrar ninguna etiquéta     * @param string $error mensaje de error     * @param array $attributes atributos del datepicker     * @param array $options datos extra     *                  'before' => html que se inserta antes     *                  'after' => html que se inserta después     * @param array|false $datepickerDiv elementos extra que tendrá el contenedor del datepicker     * @param array|false $divGroup elementos extra que tendrá el contenedor de todo el elemento     * @return string input con formato boostrap y función bootstrap-datepicker     *      * <!-- HTML de $options['before'] ->     * <!-- Se agregar la clase has-error en caso de que exista error -->     * <div class="form-group has-error">     *     <label class="control-label" for="">     *         <!-- Icono -->     *         <i class="fa fa-icon"></i>&nbsp;     *             Etiqueta     *         <!-- Información popover -->     *         <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *     </label>     *     <div>     *         <input type="hidden" name="datepicker_name" id="DatepickerName" >     *         <div class="input-group input-append date">         *             <input class="form-control bootstrapDatepicker" id="FuaDatepickerName" name="Fua[dtepicker_name]" type="text" value="valor datepicker">     *             <span class="add-on input-group-addon"><i class="fa fa-calendar-o"></i></span>     *          </div>     *          <!--En caso de que exista error-->     *          <span class="help-block"><i class="fa fa-warning"></i> Mensaje de error</span>     *     </div>     * </div>     * <!-- HTML de $options['after'] ->     */    public function datepicker($name, $value = '', $label = array(), $error = array(), $attributes = array(), $options = array(), $datepickerDiv = array(), $divGroup = array()) {        $htmlLabel = '';        $hiddenHTML = '';        $htmlError = '';        if (isset($attributes['id'])) {            if ($attributes['id'] == '') {                $idHidden = String::upperCamelize($name);            } else {                $idHidden = $attributes['id'];            }        } else {            $idHidden = String::upperCamelize($name);        }        /**         * EGMC 20150807         * Validación de la fecha 0000-00-00         */        if ($value == '0000-00-00') {            $value = '';        }        $hiddenHTML = $this->hidden($name, $value, array('id' => $idHidden));        $name = 'Fua[' . String::upperCamelize($name) . ']';        $attributes['id'] = String::upperCamelize($name);        $attributes['data-input-id'] = $idHidden;        if (isset($attributes['class'])) {            $attributes['class'] .= ' ' . $this->attrsDatepicker['class'];        }        //INICIA CONSTRUCCIÓN DE HTML INPUT        $attributes += $this->attrsDatepicker;        $options += $this->extraOptions;        $attributes['name'] = $name;//        $attributes['value'] = $value;        if ($attributes['id'] == '') {            $attributes['id'] = String::upperCamelize($name);        }        /**         * EGMC 20160216         * El cambiar formato se ve el cambio         *///        if(false)                if (!isset($attributes['value']) && $value != '') {            $attributes['value'] = date('d-m-Y', strtotime($value));        }        $htmlInput = $this->tag('input', $attributes);        /**         * agregamos el icono de reloj         */        $htmlInput .= '<span class="add-on input-group-addon"><i class="fa fa-calendar"></i></span>';        //INICIA CONSTRUCCIÓN DE HTML ERROR        if ($error !== false && !empty($error)) {            /**             * Con clases             */            //$htmlError = $this->tag('span', array('class' => 'help-block'),  $this->tag('i', array('class' => 'fa fa-warning')) .$error);            /**             * Sin Clase es más eficiente             */            $htmlError = '<span class="help-block"><i class="fa fa-warning"></i>&nbsp;' . $error . '</span>' . "\r\n";        }        //FIN CONSTRUCCIÓN DE HTML ERROR        $htmlInput = $this->tag('div', array('class' => 'input-group input-append date'), $htmlInput, array('before' => $hiddenHTML,            'after' => $htmlError));        // $htmlInput = $hiddenHTML . $htmlInput . $htmlError;        /**         * Se agregan las opciones base del div que contiene al input         */        if ($datepickerDiv !== false) {            $datepickerDiv += $this->baseDatepickerDiv;            $htmlInput = $this->div($htmlInput, $datepickerDiv['attributes'], $datepickerDiv['options']);        }        //FIN CONSTRUCCIÓN DE HTML INPUT        //        //INICIA CONSTRUCCIÓN DE HTML LABEL        if ($label !== false) {            /**             * Si la etiqueta está vacía asignamos el nombre del elemento             */            if (empty($label)) {                $label['content'] = $name;            }            /**             * Si label es una cadena entonces asignamos el contenido             */            if (is_string($label)) {                $label = (array) $label;                $label['content'] = $label[0];                unset($label[0]);            }            $label += $this->baseDatepickerLabel;            $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        }        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCCIÓN DE DIV        if ($divGroup !== false) {            $divGroup += $this->baseDivGroup;            if ($htmlError != '') {                $divGroup['attributes']['class'].=' has-error ';            }            return $options['before'] . $this->div($htmlLabel . $htmlInput, $divGroup['attributes'], $divGroup['options']) . $options['after'];        }        //FIN CONSTRUCCIÓN DE DIV        return $options['before'] . $htmlLabel . $htmlInput . $options['after'];    }    /**     * EGMC 20150723     * Regresa un elemento informativo     * @param string $value     * @param string $label     * @param array $infoDiv     * @param array $options          * @param array $divGroup     * @return string      *      * <div class="form-group">     *    <label class="control-label">     *         <!-- Icono -->     *         <i class="fa fa-icon"></i>&nbsp;     *             Etiqueta     *         <!-- Información popover -->     *         <i data-original-content="Texto informativo" class="fa fa-info-circle" data-toggle="popover" data-placement="top"></i>     *     </label>     *     <div class="control-label" style="text-align:left">     *        Valor     *     </div>     * </div>     *      */    public function information($value, $label = array(), $infoDiv = array(), $options = array(), $divGroup = array()) {//            Dbg::data($label);        $htmlLabel = '';        $options += $this->extraOptions;        /**         * Se agregan las opciones base del div que contiene el valor         */        $infoDiv += $this->baseInformationDiv;        $htmlInfo = $this->div($value, $infoDiv['attributes'], $infoDiv['options']);        //INICIA CONSTRUCCIÓN DE HTML LABEL        if ($label !== false) {            /**             * Si label es una cadena entonces asignamos el contenido             */            if (is_string($label)) {                $label = (array) $label;                $label['content'] = $label[0];                unset($label[0]);            }            $label += $this->baseInformationLabel;            $htmlLabel = $this->label($label['content'], $label['attributes'], $label['icon'], $label['infoPopover'], $label['options']);        }        //FIN CONSTRUCCIÓN DE HTML LABEL        //INICIA CONSTRUCCIÓN DE DIV        if ($divGroup !== false) {            $divGroup += $this->baseDivGroup;            return $options['before'] . $this->div($htmlLabel . $htmlInfo, $divGroup['attributes'], $divGroup['options']) . $options['after'];        }        //FIN CONSTRUCCIÓN DE DIV        return $options['before'] . $htmlLabel . $htmlInfo . $options['after'];    }}?>